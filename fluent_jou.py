# FLENTJOU.PY ==============================================================
# This module contains the definitions of various elements that go to make
# up a Fluent journal file.
#
# Assumes Fluent V15, 3D, double precision, pressure based Navier-Stokes
# solver. It can be set to run either Spalart-Allmaras, K-epsilon fully
# realisable or K-omega SST models using either first or second order methods
# to acheive convergence.
# Also that the Fluent .cas file is produced with the Harpoon mesher using
# an AirConics Rhino generated STL with standard six sided Harpoon bounding
# box and three part airframe surface (named rhinoceros_binary_stl___...).
#
# The resulting journal file runes should not generate any errors except
# for "Question OK" errors arising from file and rune status as noted below.
#
# A.J. Keane, January 2016
# ==========================================================================

from __future__ import division
import rhinoscriptsyntax as rs
import math

def fluentData(fo, FilNam, Awing, Dens, Visc, Chord, Press, Vel):
    fo.write('%s\n' % ("file"))
    fo.write('%s\n' % ("read-case"))
    fo.write('%s\n' % (FilNam))
    # note the next line somtimes generates a harmless error depending on the sequence of routine calls
    fo.write('%s\n' % ("OK"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("mesh"))
    fo.write('%s\n' % ("smooth-mesh"))
    fo.write('%s\n' % ("\"quality based\""))
    fo.write('%s\n' % ("4"))
    fo.write('%s\n' % ("0.1"))
    fo.write('%s\n' % ("q"))

    fo.write('%s\n' % ("define"))
    fo.write('%s\n' % ("models"))
    fo.write('%s\n' % ("viscous"))
    fo.write('%s\n' % ("spalart-allmaras"))
    fo.write('%s\n' % ("yes"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("materials"))
    fo.write('%s\n' % ("change"))
    fo.write('%s\n' % ("air"))
    fo.write('%s\n' % ("air"))
    fo.write('%s\n' % ("yes"))
    fo.write('%s\n' % ("constant"))
    fo.write('%s\n' % ("1.2107"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("y"))
    fo.write('%s\n' % ("constant"))
    fo.write('%s\n' % ("1.785e-05"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("q"))

    fo.write('%s\n' % ("report"))
    fo.write('%s\n' % ("ref"))
    fo.write('%s\n' % ("area"))
    fo.write('%s\n' % (Awing))
    fo.write('%s\n' % ("density"))
    fo.write('%s\n' % (Dens))
    fo.write('%s\n' % ("viscosity"))
    fo.write('%s\n' % (Visc))
    fo.write('%s\n' % ("length"))
    fo.write('%s\n' % (Chord/1000.0))
    fo.write('%s\n' % ("pressure"))
    fo.write('%s\n' % (Press))
    fo.write('%s\n' % ("velocity"))
    fo.write('%s\n' % (Vel))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("summary"))
    fo.write('%s\n' % ("no"))
    fo.write('%s\n' % ("q"))

    fo.write('%s\n' % ("solve"))
    fo.write('%s\n' % ("monitors"))
    fo.write('%s\n' % ("resid"))
    fo.write('%s\n' % ("criterion-type"))
    fo.write('%s\n' % ("3"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("q"))

    fo.write('%s\n' % ("define"))
    fo.write('%s\n' % ("bound"))
    fo.write('%s\n' % ("list"))
    fo.write('%s\n' % ("mod"))
    fo.write('%s\n' % ("zone-type"))
    fo.write('%s\n' % ("farfield_minx"))
    fo.write('%s\n' % ("velocity-inlet"))
    fo.write('%s\n' % ("zone-type"))
    fo.write('%s\n' % ("farfield_minz"))
    fo.write('%s\n' % ("velocity-inlet"))
    fo.write('%s\n' % ("zone-type"))
    fo.write('%s\n' % ("farfield_maxx"))
    fo.write('%s\n' % ("pressure-outlet"))
    fo.write('%s\n' % ("zone-type"))
    fo.write('%s\n' % ("farfield_maxz"))
    fo.write('%s\n' % ("pressure-outlet"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("q"))

def fluentBCs(fo, Vel, AoA, BName, Nmod):
    # model = 0 for Spalart Allmaras, 1 for K-epsilon fully realisable and 2 for K-omega SST
    XVec = math.cos(math.radians(AoA))
    ZVec = math.sin(math.radians(AoA))
    XVel = Vel * math.cos(math.radians(AoA))
    ZVel = Vel * math.sin(math.radians(AoA))
    fo.write('%s \n' % ("solve"))
    fo.write('%s \n' % ("monitors"))
    fo.write('%s \n' % ("force"))
    fo.write('%s \n' % ("set-lift"))
    fo.write('%s \n' % ("cl-1"))
    fo.write('%s \n' % ("y"))
    fo.write('%s \n' % (BName))
    fo.write('%s \n' % (""))
    fo.write('%s \n' % ("y"))
    fo.write('%s \n' % ("n"))
    fo.write('%s \n' % ("n"))
    fo.write('%s \n' % ("n"))
    fo.write('%s \n' % (-ZVec))
    fo.write('%s \n' % ("0"))
    fo.write('%s \n' % (XVec))
    fo.write('%s \n' % ("set-drag"))
    fo.write('%s \n' % ("cd-1"))
    fo.write('%s \n' % ("y"))
    fo.write('%s \n' % (BName))
    fo.write('%s \n' % (""))
    fo.write('%s \n' % ("y"))
    fo.write('%s \n' % ("n"))
    fo.write('%s \n' % ("n"))
    fo.write('%s \n' % ("n"))
    fo.write('%s \n' % (XVec))
    fo.write('%s \n' % ("0"))
    fo.write('%s \n' % (ZVec))
    fo.write('%s \n' % ("q"))
    fo.write('%s \n' % ("q"))
    fo.write('%s \n' % ("q"))

    fo.write('%s\n' % ("define"))
    fo.write('%s\n' % ("bound"))
    fo.write('%s\n' % ("vel"))
    fo.write('%s\n' % ("farfield_minx"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("y"))
    fo.write('%s\n' % ("y"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("0"))
    fo.write('%s\n' % ("y"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % (XVel))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("0"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % (ZVel))
    
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("y"))
    if( Nmod == 0):
        fo.write('%s\n' % ("n"))
    else:
        fo.write('%s\n' % ("0.1"))
    fo.write('%s\n' % ("0.1"))
    fo.write('%s\n' % ("press"))
    fo.write('%s\n' % ("farfield_maxx"))
    fo.write('%s\n' % ("y")) # this line is needed by fluent V17.1
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("0"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("y"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("y"))
    if( Nmod == 0):
        fo.write('%s\n' % ("n"))
    else:
        fo.write('%s\n' % ("1"))
    fo.write('%s\n' % ("1"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("n"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("q"))

    if (AoA < 0.0):
        fo.write('%s\n' % ("define"))
        fo.write('%s\n' % ("bound"))
        fo.write('%s\n' % ("mod"))
        fo.write('%s\n' % ("zone-type"))
        fo.write('%s\n' % ("farfield_maxz"))
        fo.write('%s\n' % ("velocity-inlet"))
        fo.write('%s\n' % ("zone-type"))
        fo.write('%s\n' % ("farfield_minz"))
        fo.write('%s\n' % ("pressure-outlet"))
        fo.write('%s\n' % ("q"))
        fo.write('%s\n' % ("vel"))
        fo.write('%s\n' % ("farfield_maxz"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("y"))
        fo.write('%s\n' % ("y"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("0"))
        fo.write('%s\n' % ("y"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % (XVel))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("0"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % (ZVel))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("y"))
        fo.write('%s\n' % ("n"))
        if( Nmod == 0):
            fo.write('%s\n' % ("n"))
        else:
            fo.write('%s\n' % ("0.1"))
        fo.write('%s\n' % ("0.1"))
        fo.write('%s\n' % ("press"))
        fo.write('%s\n' % ("farfield_minz"))
        fo.write('%s\n' % ("y")) # this line is needed by fluent V17.1
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("0"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("y"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("y"))
        fo.write('%s\n' % ("n"))
        if( Nmod == 0):
            fo.write('%s\n' % ("n"))
        else:
            fo.write('%s\n' % ("1"))
        fo.write('%s\n' % ("1"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("q"))
        fo.write('%s\n' % ("q"))
    elif (AoA > 0.0):
        fo.write('%s\n' % ("define"))
        fo.write('%s\n' % ("bound"))
        fo.write('%s\n' % ("mod"))
        fo.write('%s\n' % ("zone-type"))
        fo.write('%s\n' % ("farfield_minz"))
        fo.write('%s\n' % ("velocity-inlet"))
        fo.write('%s\n' % ("zone-type"))
        fo.write('%s\n' % ("farfield_maxz"))
        fo.write('%s\n' % ("pressure-outlet"))
        fo.write('%s\n' % ("q"))
        fo.write('%s\n' % ("vel"))
        fo.write('%s\n' % ("farfield_minz"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("y"))
        fo.write('%s\n' % ("y"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("0"))
        fo.write('%s\n' % ("y"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % (XVel))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("0"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % (ZVel))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("y"))
        fo.write('%s\n' % ("n"))
        if( Nmod == 0):
            fo.write('%s\n' % ("n"))
        else:
            fo.write('%s\n' % ("0.1"))
        fo.write('%s\n' % ("0.1"))
        fo.write('%s\n' % ("press"))
        fo.write('%s\n' % ("farfield_maxz"))
        fo.write('%s\n' % ("y")) # this line is needed by fluent V17.1
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("0"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("y"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("y"))
        fo.write('%s\n' % ("n"))
        if( Nmod == 0):
            fo.write('%s\n' % ("n"))
        else:
            fo.write('%s\n' % ("1"))
        fo.write('%s\n' % ("1"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("n"))
        fo.write('%s\n' % ("q"))
        fo.write('%s\n' % ("q"))
    else:
        fo.write('%s\n' % ("define"))
        fo.write('%s\n' % ("bound"))
        fo.write('%s\n' % ("mod"))
        fo.write('%s\n' % ("zone-type"))
        fo.write('%s\n' % ("farfield_minz"))
        fo.write('%s\n' % ("symmetry"))
        fo.write('%s\n' % ("zone-type"))
        fo.write('%s\n' % ("farfield_maxz"))
        fo.write('%s\n' % ("symmetry"))
        fo.write('%s\n' % ("q"))
        fo.write('%s\n' % ("q"))
        fo.write('%s\n' % ("q"))

def fluentInitc(fo, Vel, AoA):
    XVel = Vel * math.cos(math.radians(AoA))
    ZVel = Vel * math.sin(math.radians(AoA))

    fo.write('%s\n' % ("solve"))
    fo.write('%s\n' % ("init"))
    fo.write('%s\n' % ("set-def"))
    fo.write('%s\n' % ("x-v"))
    fo.write('%s\n' % (XVel))
    fo.write('%s\n' % ("y-v"))
    fo.write('%s\n' % ("0.0"))
    fo.write('%s\n' % ("z-v"))
    fo.write('%s\n' % (ZVel))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("init"))
    fo.write('%s\n' % ("init"))
    fo.write('%s\n' % ("ok"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("q"))

def fluentCalc(fo, Nits, relax):
    fo.write('%s\n' % ("solve"))
#    fo.write('%s\n' % ("monitors"))
#    fo.write('%s\n' % ("resid"))
#    fo.write('%s\n' % ("criterion-type"))
#    fo.write('%s\n' % ("0"))
#    fo.write('%s\n' % ("q"))
#    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("set"))
#    fo.write('%s\n' % ("disc"))
#    fo.write('%s\n' % ("mom"))
#    fo.write('%s\n' % ("0"))
#    fo.write('%s\n' % ("q"))
    # next we turn down the relaxation on first order momentum to stabilize the calculation (not always needed - default is 0.7)
    fo.write('%s\n' % ("under"))
    fo.write('%s\n' % ("mom"))
    fo.write('%s\n' % (relax))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("solve"))
    fo.write('%s\n' % ("set"))
    fo.write('%s\n' % ("report"))
    fo.write('%s\n' % ("10"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("iterate"))
    fo.write('%s\n' % (Nits))
    fo.write('%s\n' % ("q"))

def fluentAdapt(fo, Nlow, Nupp):
    fo.write('%s\n' % ("adapt"))
    fo.write('%s\n' % ("adapt-to-y+"))
    fo.write('%s\n' % (Nlow))
    fo.write('%s\n' % (Nupp))
    fo.write('%s\n' % ("0"))
    fo.write('%s\n' % ("1000"))
    fo.write('%s\n' % ("yes"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("mesh"))
    fo.write('%s\n' % ("smooth-mesh"))
    fo.write('%s\n' % ("\"quality based\""))
    fo.write('%s\n' % ("4"))
    fo.write('%s\n' % ("0.1"))
    fo.write('%s\n' % ("q"))


def fluentModel(fo, Nmod):
    # model = 0 for Spalart Allmaras, 1 for K-epsilon fully realisable and 2 for K-omega SST
    if( Nmod == 0):
        fo.write('%s\n' % ("define"))
        fo.write('%s\n' % ("models"))
        fo.write('%s\n' % ("viscous"))
        fo.write('%s\n' % ("spalart-allmaras"))
        fo.write('%s\n' % ("yes"))
        fo.write('%s\n' % ("q"))
        fo.write('%s\n' % ("q"))
        fo.write('%s\n' % ("q"))
    elif( Nmod == 1):
        fo.write('%s\n' % ("define"))
        fo.write('%s\n' % ("models"))
        fo.write('%s\n' % ("viscous"))
        fo.write('%s\n' % ("ke-realizable"))
        fo.write('%s\n' % ("yes"))
        fo.write('%s\n' % ("q"))
        fo.write('%s\n' % ("q"))
        fo.write('%s\n' % ("q"))
    else:
        fo.write('%s\n' % ("define"))
        fo.write('%s\n' % ("models"))
        fo.write('%s\n' % ("viscous"))
        fo.write('%s\n' % ("kw-sst"))
        fo.write('%s\n' % ("yes"))
        fo.write('%s\n' % ("q"))
        fo.write('%s\n' % ("q"))
        fo.write('%s\n' % ("q"))

def fluentMethod(fo, Nmod, Nmeth):
    # method = 0 for first order and 1 for second order
    # model is needed to know which terms to change
    # model = 0 for Spalart Allmaras, 1 for K-epsilon fully realisable and 2 for K-omega SST
    if( Nmod == 0):
        if( Nmeth == 0):
            fo.write('%s\n' % ("solve"))
            fo.write('%s\n' % ("set"))
            fo.write('%s\n' % ("disc"))
            fo.write('%s\n' % ("mom"))
            fo.write('%s\n' % ("0"))
            fo.write('%s\n' % ("nut"))
            fo.write('%s\n' % ("0"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))
        else:
            fluentCalc(fo, 100, 0.2)
            fo.write('%s\n' % ("solve"))
            fo.write('%s\n' % ("set"))
            fo.write('%s\n' % ("disc"))
            fo.write('%s\n' % ("mom"))
            fo.write('%s\n' % ("1"))
            fo.write('%s\n' % ("nut"))
            fo.write('%s\n' % ("1"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("under"))
            fo.write('%s\n' % ("mom"))
            fo.write('%s\n' % ("0.1"))
            fo.write('%s\n' % ("pressure"))
            fo.write('%s\n' % ("0.1"))
            fo.write('%s\n' % ("density"))
            fo.write('%s\n' % ("0.5"))
            fo.write('%s\n' % ("body-force"))
            fo.write('%s\n' % ("0.5"))
            fo.write('%s\n' % ("turb"))
            fo.write('%s\n' % ("0.5"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))
    elif( Nmod == 1):
        if( Nmeth == 0):
            fo.write('%s\n' % ("solve"))
            fo.write('%s\n' % ("set"))
            fo.write('%s\n' % ("disc"))
            fo.write('%s\n' % ("mom"))
            fo.write('%s\n' % ("0"))
            fo.write('%s\n' % ("k"))
            fo.write('%s\n' % ("0"))
            fo.write('%s\n' % ("epsilon"))
            fo.write('%s\n' % ("0"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))
        else:
            fo.write('%s\n' % ("solve"))
            fo.write('%s\n' % ("set"))
            fo.write('%s\n' % ("disc"))
            fo.write('%s\n' % ("mom"))
            fo.write('%s\n' % ("1"))
            fo.write('%s\n' % ("k"))
            fo.write('%s\n' % ("1"))
            fo.write('%s\n' % ("epsilon"))
            fo.write('%s\n' % ("1"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))
    else:
        if( Nmeth == 0):
            fo.write('%s\n' % ("solve"))
            fo.write('%s\n' % ("set"))
            fo.write('%s\n' % ("disc"))
            fo.write('%s\n' % ("mom"))
            fo.write('%s\n' % ("0"))
            fo.write('%s\n' % ("k"))
            fo.write('%s\n' % ("0"))
            fo.write('%s\n' % ("omega"))
            fo.write('%s\n' % ("0"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))
        else:
            fo.write('%s\n' % ("solve"))
            fo.write('%s\n' % ("set"))
            fo.write('%s\n' % ("disc"))
            fo.write('%s\n' % ("k"))
            fo.write('%s\n' % ("1"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))
            fluentCalc(fo, 100, 0.2)
            fo.write('%s\n' % ("solve"))
            fo.write('%s\n' % ("set"))
            fo.write('%s\n' % ("disc"))
            fo.write('%s\n' % ("omega"))
            fo.write('%s\n' % ("1"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))
            fluentCalc(fo, 100, 0.2)
            fo.write('%s\n' % ("solve"))
            fo.write('%s\n' % ("set"))
            fo.write('%s\n' % ("disc"))
            fo.write('%s\n' % ("mom"))
            fo.write('%s\n' % ("1"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("under"))
            fo.write('%s\n' % ("mom"))
            fo.write('%s\n' % ("0.1"))
            fo.write('%s\n' % ("pressure"))
            fo.write('%s\n' % ("0.1"))
            fo.write('%s\n' % ("density"))
            fo.write('%s\n' % ("0.5"))
            fo.write('%s\n' % ("body-force"))
            fo.write('%s\n' % ("0.5"))
            fo.write('%s\n' % ("turb"))
            fo.write('%s\n' % ("0.5"))
            fo.write('%s\n' % ("k"))
            fo.write('%s\n' % ("0.5"))
            fo.write('%s\n' % ("omega"))
            fo.write('%s\n' % ("0.5"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))
            fo.write('%s\n' % ("q"))

def fluentRunOn(fo, Nits):
    fo.write('%s\n' % ("solve"))
    fo.write('%s\n' % ("monitors"))
    fo.write('%s\n' % ("resid"))
    fo.write('%s\n' % ("criterion-type"))
    fo.write('%s\n' % ("3"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("solve"))
    fo.write('%s\n' % ("iterate"))
    fo.write('%s\n' % (Nits))
    fo.write('%s\n' % ("q"))

def fluentReport(fo, FilNam):
    fo.write('%s\n' % ("report"))
    fo.write('%s\n' % ("forces"))
    fo.write('%s\n' % ("wall-forces"))
    fo.write('%s\n' % ("y"))
    fo.write('%s\n' % ("1"))
    fo.write('%s\n' % ("0"))
    fo.write('%s\n' % ("0"))
    fo.write('%s\n' % ("y"))
    fo.write('%s%s\n' % (FilNam,"_X.txt"))
    # note the next line somtimes generates a harmless error depending on the sequence of routine calls
    fo.write('%s\n' % ("yes"))
    fo.write('%s\n' % ("wall-forces"))
    fo.write('%s\n' % ("y"))
    fo.write('%s\n' % ("0"))
    fo.write('%s\n' % ("0"))
    fo.write('%s\n' % ("1"))
    fo.write('%s\n' % ("y"))
    fo.write('%s%s\n' % (FilNam,"_Z.txt"))
    # note the next line somtimes generates a harmless error depending on the sequence of routine calls
    fo.write('%s\n' % ("yes"))
    fo.write('%s\n' % ("q"))
    fo.write('%s\n' % ("q"))

if __name__ == "__main__":
# now write out matching Fluent journal file
    
    Awing=0.966
    V_T=16.00
    rho_C=1.2107
    Visc_C=1.785E-05
    Chord=0.3
    Pr_C=0.0
    
    Nits=5
    Nrunon=5
    Nlow=75
    Nupp=150
    
    fo = open("fluent_journal.jou", "w")
    for AoA in range(-1, 2):
        fluentData(fo, "Decode1coarse.cas", Awing, rho_C, Visc_C, Chord, Pr_C, V_T)
        fluentBCs(fo, V_T, AoA, "rhinoceros_binary_stl___aug_10_2015.1\nrhinoceros_binary_stl___aug_10_2015.1.1", 0) # nb using extra BC names seperated by \n is harmless - if the BC does not exist it is ignored
        fluentModel(fo, 0) # model 0 is SA while 1 is Ke and 2 is Kw
        fluentMethod(fo, 0, 0) # model and method, method 0 is first order while 1 is second order
        fluentInitc(fo, V_T, AoA)
        fluentCalc(fo, Nits, 0.7)
        fluentAdapt(fo, Nlow, Nupp)
        fluentMethod(fo, 0, 1) # model and method, method 0 is first order while 1 is second order
        fluentCalc(fo, Nits, 0.7)
        fluentReport(fo, "Decode1")
        fluentModel(fo, 1) # model 0 is SA while 1 is Ke and 2 is Kw
        fluentMethod(fo, 1, 0) # model and method, method 0 is first order while 1 is second order
        fluentCalc(fo, Nits, 0.7)
        fluentAdapt(fo, Nlow, Nupp)
        fluentMethod(fo, 1, 1) # model and method, method 0 is first order while 1 is second order
        fluentCalc(fo, Nits, 0.7)
        fluentReport(fo, "Decode1")
        fluentModel(fo, 2) # model 0 is SA while 1 is Ke and 2 is Kw
        fluentMethod(fo, 2, 0) # model and method, method 0 is first order while 1 is second order
        fluentCalc(fo, Nits, 0.7)
        fluentAdapt(fo, Nlow, Nupp)
        fluentMethod(fo, 2, 1) # model and method, method 0 is first order while 1 is second order
        fluentCalc(fo, Nits, 0.7)
        fluentRunOn(fo, Nrunon)
        fluentReport(fo, "Decode1")
    fo.close()